# Implements sandhi phenomena, such as elision, resyllabification,
# synezisis, hypermetric lengthening, etc.

import 'byte.grm' as b;
import 'inventory.grm' as i;
import 'utility.grm' as u;

sigma_star = (i.PROSODIC_SYMBOL | i.PHONEME)*;

# A final syllable ending in a vowel or letter m is removed
# before a word beginning with a vowel (or an h-).
export ELISION = Optimize[
    CDRewrite[u.Delete[i.PHONEMIC_VOWEL i.EOW], "", i.PHONEMIC_VOWEL,
                       sigma_star, 'ltr', 'opt'] @
    CDRewrite[u.Delete[i.PHONEMIC_VOWEL i.EOW "h"], "", i.PHONEMIC_VOWEL,
                       sigma_star, 'ltr', 'opt']
];

# Word-final consonant reattaches to the following word with an initial vowel.
export RESYLLABIFY = Optimize[
    CDRewrite[u.Insert[" "], "", i.CONSONANT " " i.PHONEMIC_VOWEL, sigma_star, 'ltr', 'opt'] @
    CDRewrite[u.Delete[" "], " " i.CONSONANT, i.PHONEMIC_VOWEL, sigma_star]
];
# TODO: orthographically annotate using "‿".

## Resyllabification tests.

# Jūnōnis ob īram.
test_without_resyllabify_1= AssertEqual["juːnoːnis ob iːrãː" @ RESYLLABIFY, "juːnoːnis ob iːrãː"];
test_with_resyllabify_1 = AssertEqual["juːnoːnis ob iːrãː" @ RESYLLABIFY, "juːnoːni so biːrãː"];

# conderet urbem.
test_without_resyllabify_2 = AssertEqual["konderet urbẽː" @ RESYLLABIFY, "konderet urbẽː"];
test_with_resyllabify_2 = AssertEqual["konderet urbẽː" @ RESYLLABIFY, "kondere turbẽː"];

## Elision tests.

test_without_elision_1= AssertEqual["atkwe hominũː" @ ELISION, "atkwe hominũː"];
test_with_elision_1 = AssertEqual["atkwe hominũː" @ ELISION, "atkwominũː"];

test_without_elision_2= AssertEqual["tantajne animiːs" @ ELISION, "tantajne animiːs"];
test_with_elision_2 = AssertEqual["tantajne animiːs" @ ELISION, "tantajnanimiːs"];

test_without_elision_3= AssertEqual["multũː ille" @ ELISION, "multũː ille"];
test_with_elision_3 = AssertEqual["multũː ille" @ ELISION, "multille"];
